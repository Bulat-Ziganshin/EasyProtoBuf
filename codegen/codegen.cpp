#include <string>
#include <cctype>
#include <iostream>
#include <fstream>
#include <iterator>

#include <easypb.hpp>
#include "descriptor.pb.cpp"
#include "utils.cpp"


// Protobuf and C++ delimiters between parts of a qualified name
const std::string PB_TYPE_DELIMITER = ".";
const std::string CPP_TYPE_DELIMITER = "::";


// Command-line options affecting the generated code
struct
{
    bool no_class;
    bool no_decoder;
    bool no_encoder;
    bool no_has_fields;
    bool no_required;
    bool no_default_values;
    bool packed;
    bool no_packed;
    std::string cpp_string_type;
    std::string cpp_repeated_type;
} option;


const char* FILE_TEMPLATE =
R"---(// Generated by a ProtoBuf compiler.  DO NOT EDIT!
// Source: {0}

#include <cstdint>
#include <string>
#include <vector>

)---";


// {0}=message_type.name, {1}=field_defs, {2}=has_field_defs, {3}=encoder declaration, {4}=decoder declaration
const char* CLASS_TEMPLATE = R"---(
struct {0}
{
{1}
{2}
#ifdef EASYPB_{0}_EXTRA_FIELDS
EASYPB_{0}_EXTRA_FIELDS
#endif
{3}
{4}
};
)---";

const char* ENCODER_DECLARATION_TEMPLATE =
"    void encode(easypb::Encoder &pb);";

const char* DECODER_DECLARATION_TEMPLATE =
"    void decode(easypb::Decoder pb);";


// {0}=message_type.name, {1}=encoder
const char* ENCODER_TEMPLATE = R"---(
void {0}::encode(easypb::Encoder &pb)
{
{1}
#ifdef EASYPB_{0}_EXTRA_ENCODING
EASYPB_{0}_EXTRA_ENCODING
#endif
}
)---";


// {0}=message_type.name, {1}=decoder, {2}=check_required_fields
const char* DECODER_TEMPLATE = R"---(
void {0}::decode(easypb::Decoder pb)
{
    while(pb.get_next_field())
    {
        switch(pb.field_num)
        {
{1}
#ifdef EASYPB_{0}_EXTRA_DECODING
EASYPB_{0}_EXTRA_DECODING
#endif
            default: pb.skip_field();
        }
    }
#ifdef EASYPB_{0}_EXTRA_POST_DECODING
EASYPB_{0}_EXTRA_POST_DECODING
#endif
{2}
}
)---";


// {0}=message_type.name, {1}=field.name
const char* CHECK_REQUIRED_FIELD_TEMPLATE = R"---(
    if(! has_{1}) {
        throw std::runtime_error("Decoded protobuf has no required field {0}.{1}");
    }
)---";



// Is it a repeated Protobuf field?
bool is_repeated(FieldDescriptorProto &field)
{
    return (field.label == FieldDescriptorProto::LABEL_REPEATED);
}


// Does this field have corresponding has_* flag?
bool hasfield_enabled(FieldDescriptorProto &field)
{
    return (! is_repeated(field)  &&  ! option.no_has_fields);
}


// Is it a Protobuf numeric field (including enums/bools)?
bool is_numeric_field(FieldDescriptorProto &field)
{
    return (field.type != FieldDescriptorProto::TYPE_STRING) &&
           (field.type != FieldDescriptorProto::TYPE_BYTES) &&
           (field.type != FieldDescriptorProto::TYPE_MESSAGE) &&
           (field.type != FieldDescriptorProto::TYPE_GROUP);
}


// Serialize this field in the more compact "packed" Protobuf wire format?
bool write_as_packed(FieldDescriptorProto &field)
{
    return is_repeated(field) &&
           is_numeric_field(field) &&
           (option.packed ?    true :
            option.no_packed ? false :
                               field.options.packed);
}


// PB type as used in .proto file (e.g. "fixed32")
std::string_view protobuf_type_as_str(FieldDescriptorProto &field)
{
    switch(field.type)
    {
        case FieldDescriptorProto::TYPE_DOUBLE:    return "double";
        case FieldDescriptorProto::TYPE_FLOAT:     return "float";
        case FieldDescriptorProto::TYPE_INT64:     return "int64";
        case FieldDescriptorProto::TYPE_UINT64:    return "uint64";
        case FieldDescriptorProto::TYPE_INT32:     return "int32";
        case FieldDescriptorProto::TYPE_FIXED64:   return "fixed64";
        case FieldDescriptorProto::TYPE_FIXED32:   return "fixed32";
        case FieldDescriptorProto::TYPE_BOOL:      return "bool";
        case FieldDescriptorProto::TYPE_STRING:    return "string";
        case FieldDescriptorProto::TYPE_GROUP:     return "?group";
        case FieldDescriptorProto::TYPE_MESSAGE:   return "message";
        case FieldDescriptorProto::TYPE_BYTES:     return "bytes";
        case FieldDescriptorProto::TYPE_UINT32:    return "uint32";
        case FieldDescriptorProto::TYPE_ENUM:      return "enum";
        case FieldDescriptorProto::TYPE_SFIXED32:  return "sfixed32";
        case FieldDescriptorProto::TYPE_SFIXED64:  return "sfixed64";
        case FieldDescriptorProto::TYPE_SINT32:    return "sint32";
        case FieldDescriptorProto::TYPE_SINT64:    return "sint64";
    }

    return "?type";
}


// Return the shortest [qualified] C++ type corresponding to the fully qualified Protobuf message/enum type
std::string cpp_qualified_type_str(std::string_view package_name_prefix, std::string_view msgtype_name_prefix, std::string_view message_type)
{
    // Strip the package_name_prefix from the fully qualified message_type,
    // e.g. (".google.protobuf.", ".google.protobuf.DescriptorProto.ExtensionRange") -> "DescriptorProto.ExtensionRange",
    // then drop the prefix of the current msgtype (e.g. "DescriptorProto."),
    // and finally replace "." typename separator with "::"

    // If message type starts with ".PACKAGE_NAME.", drop this prefix
    auto prefix_len = package_name_prefix.length();
    if (message_type.substr(0, prefix_len) == package_name_prefix) {
        message_type = message_type.substr(prefix_len);

        // If message type starts with "CURRENT_MSGTYPE_NAME.", drop this prefix
        auto prefix_len = msgtype_name_prefix.length();
        if (message_type.substr(0, prefix_len) == msgtype_name_prefix) {
            message_type = message_type.substr(prefix_len);
        }
    }

    // Finally, replace "." between name components with C++-specific "::"
    return string_replace_all(message_type, PB_TYPE_DELIMITER, CPP_TYPE_DELIMITER );
}


// Return C++ type corresponding to the base type (without "repeated") of the Protobuf field
std::string base_cpp_type_as_str(std::string_view package_name_prefix, std::string_view msgtype_name_prefix, FieldDescriptorProto &field)
{
    // According to https://github.com/protocolbuffers/protobuf/blob/c05b320d9c18173bfce36c4bef22f9953d340ff9/src/google/protobuf/descriptor.h#L780
    switch(field.type)
    {
        case FieldDescriptorProto::TYPE_INT32:
        case FieldDescriptorProto::TYPE_SINT32:
        case FieldDescriptorProto::TYPE_SFIXED32: return "int32_t";

        case FieldDescriptorProto::TYPE_INT64:
        case FieldDescriptorProto::TYPE_SINT64:
        case FieldDescriptorProto::TYPE_SFIXED64: return "int64_t";

        case FieldDescriptorProto::TYPE_UINT32:
        case FieldDescriptorProto::TYPE_FIXED32:  return "uint32_t";

        case FieldDescriptorProto::TYPE_UINT64:
        case FieldDescriptorProto::TYPE_FIXED64:  return "uint64_t";

        case FieldDescriptorProto::TYPE_DOUBLE:   return "double";

        case FieldDescriptorProto::TYPE_FLOAT:    return "float";

        case FieldDescriptorProto::TYPE_BOOL:     return "bool";

        case FieldDescriptorProto::TYPE_ENUM:     return "int32_t";

        case FieldDescriptorProto::TYPE_STRING:
        case FieldDescriptorProto::TYPE_BYTES:    return option.cpp_string_type;

        case FieldDescriptorProto::TYPE_MESSAGE:  return cpp_qualified_type_str(package_name_prefix, msgtype_name_prefix, field.type_name);

        case FieldDescriptorProto::TYPE_GROUP:    return "?group";
    }

    return "?type";
}


// Return C++ type for the Protobuf field
std::string cpp_type_as_str(std::string_view package_name_prefix, std::string_view msgtype_name_prefix, FieldDescriptorProto &field)
{
    auto base_type = base_cpp_type_as_str(package_name_prefix, msgtype_name_prefix, field);

    if (is_repeated(field)) {
        return myformat(option.cpp_repeated_type, base_type);
    } else {
        return base_type;
    }
}


// Either " = default_field_value" or empty string
std::string default_value_str(FieldDescriptorProto &field)
{
    if (field.has_default_value  &&  ! option.no_default_values) {
        bool is_bytearray_field = (field.type==FieldDescriptorProto::TYPE_STRING || field.type==FieldDescriptorProto::TYPE_BYTES);
        const char* quote_str = (is_bytearray_field? "\"" : "");
        return myformat(" = {0}{1}{0}", quote_str, field.default_value);
    } else if (is_repeated(field)) {
        return "";
    } else {
        // C++ doesn't initialize scalar fields by default, so we need to enforce the initialization
        return field.type == FieldDescriptorProto::TYPE_BOOL
                   ? " = false" :
               is_numeric_field(field)
                   ? " = 0"
               // or another field type
                   : "";
    }
}


// Encoder code for a single field
std::string generate_field_encoder(FieldDescriptorProto &field)
{
    return myformat("    pb.put_{0}{1}({2}, {3});\n",
    /* 0 */ is_repeated(field)
                ? (write_as_packed(field)? "packed_" : "repeated_")
                : "",
    /* 1 */ protobuf_type_as_str(field),
    /* 2 */ std::to_string(field.number),
    /* 3 */ field.name);
}


// Decoder code for a single field
std::string generate_field_decoder(FieldDescriptorProto &field)
{
    return myformat("            case {0}: pb.get_{1}{2}(&{3}{4}); break;\n",
    /* 0 */ std::to_string(field.number),
    /* 1 */ is_repeated(field)? "repeated_" : "",
    /* 2 */ protobuf_type_as_str(field),
    /* 3 */ field.name,
    /* 4 */ hasfield_enabled(field)
                ? myformat(", &has_{0}", field.name)
                : "");
}


// Generate C++ code for the entire .pbs file
void generator(FileDescriptorSet &proto)
{
    auto file = proto.file[0];
    auto package_name_prefix =
        file.package > ""
            ? PB_TYPE_DELIMITER + std::string(file.package) + PB_TYPE_DELIMITER
            : PB_TYPE_DELIMITER;

    for (auto message_type: file.message_type)
    {
        std::string field_defs, has_field_defs, encoder, decoder, check_required_fields;
        auto msgtype_name_prefix = std::string(message_type.name) + PB_TYPE_DELIMITER;

        for (auto field: message_type.field)
        {
            // Generate message structure
            auto cpptype_str = cpp_type_as_str(package_name_prefix, msgtype_name_prefix, field);  // C++ type for the field (e.g. "std::vector<int32_t>")
            field_defs += myformat("    {} {}{};\n", cpptype_str, field.name, default_value_str(field));

            if (hasfield_enabled(field)) {
                has_field_defs += myformat("    bool has_{} = false;\n", field.name);
            }

            // Generate message encoding function
            encoder += generate_field_encoder(field);

            // Generate message decoding function
            decoder += generate_field_decoder(field);

            if ((field.label == FieldDescriptorProto::LABEL_REQUIRED)  &&  ! option.no_required) {
                check_required_fields += myformat(CHECK_REQUIRED_FIELD_TEMPLATE, message_type.name, field.name);
            }
        }

        if(! option.no_class) {
            std::cout << myformat(CLASS_TEMPLATE, message_type.name, field_defs, has_field_defs,
                option.no_encoder? "" : ENCODER_DECLARATION_TEMPLATE,
                option.no_decoder? "" : DECODER_DECLARATION_TEMPLATE);
        }
        if(! option.no_encoder) {
            std::cout << myformat(ENCODER_TEMPLATE, message_type.name, encoder);
        }
        if(! option.no_decoder) {
            std::cout << myformat(DECODER_TEMPLATE, message_type.name, decoder, check_required_fields);
        }
    }
}
